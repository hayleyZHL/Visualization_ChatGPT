





<!--.block, Click to add nodes! Nodes near the cursor will be linked to the new node.-->

<!--<!DOCTYPE html>-->
<!--<meta charset="utf-8">-->
<!--<style>-->

<!--  rect {-->
<!--    fill: none;-->
<!--    pointer-events: all;-->
<!--  }-->

<!--  .node {-->
<!--    fill: #000;-->
<!--  }-->

<!--  .cursor {-->
<!--    fill: none;-->
<!--    stroke: brown;-->
<!--    pointer-events: none;-->
<!--  }-->

<!--  .link {-->
<!--    stroke: #999;-->
<!--  }-->

<!--</style>-->
<!--<body>-->
<!--<script src="//d3js.org/d3.v3.min.js"></script>-->
<!--<script>-->

<!--  var width = 960,-->
<!--          height = 500;-->

<!--  var fill = d3.scale.category20();-->

<!--  var force = d3.layout.force()-->
<!--          .size([width, height])-->
<!--          .nodes([{}]) // initialize with a single node-->
<!--          .linkDistance(30)-->
<!--          .charge(-60)-->
<!--          .on("tick", tick);-->

<!--  var svg = d3.select("body").append("svg")-->
<!--          .attr("width", width)-->
<!--          .attr("height", height)-->
<!--          .on("mousemove", mousemove)-->
<!--          .on("mousedown", mousedown);-->

<!--  svg.append("rect")-->
<!--          .attr("width", width)-->
<!--          .attr("height", height);-->

<!--  var nodes = force.nodes(),-->
<!--          links = force.links(),-->
<!--          node = svg.selectAll(".node"),-->
<!--          link = svg.selectAll(".link");-->

<!--  var cursor = svg.append("circle")-->
<!--          .attr("r", 30)-->
<!--          .attr("transform", "translate(-100,-100)")-->
<!--          .attr("class", "cursor");-->

<!--  restart();-->

<!--  function mousemove() {-->
<!--    cursor.attr("transform", "translate(" + d3.mouse(this) + ")");-->
<!--  }-->

<!--  function mousedown() {-->
<!--    var point = d3.mouse(this),-->
<!--            node = {x: point[0], y: point[1]},-->
<!--            n = nodes.push(node);-->

<!--    // add links to any nearby nodes-->
<!--    nodes.forEach(function(target) {-->
<!--      var x = target.x - node.x,-->
<!--              y = target.y - node.y;-->
<!--      if (Math.sqrt(x * x + y * y) < 30) {-->
<!--        links.push({source: node, target: target});-->
<!--      }-->
<!--    });-->

<!--    restart();-->
<!--  }-->

<!--  function tick() {-->
<!--    link.attr("x1", function(d) { return d.source.x; })-->
<!--            .attr("y1", function(d) { return d.source.y; })-->
<!--            .attr("x2", function(d) { return d.target.x; })-->
<!--            .attr("y2", function(d) { return d.target.y; });-->

<!--    node.attr("cx", function(d) { return d.x; })-->
<!--            .attr("cy", function(d) { return d.y; });-->
<!--  }-->

<!--  function restart() {-->
<!--    link = link.data(links);-->

<!--    link.enter().insert("line", ".node")-->
<!--            .attr("class", "link");-->

<!--    node = node.data(nodes);-->

<!--    node.enter().insert("circle", ".cursor")-->
<!--            .attr("class", "node")-->
<!--            .attr("r", 5)-->
<!--            .call(force.drag);-->

<!--    force.start();-->
<!--  }-->

<!--</script>-->
<!--</body>-->
<!--</html>-->



<!--Hello, curved textPath!-->
<!--<!DOCTYPE html>-->
<!--<meta charset="utf-8">-->
<!--<style>-->

<!--  path {-->
<!--    fill: #3182bd;-->
<!--  }-->

<!--  text {-->
<!--    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;-->
<!--    font-size: 24px;-->
<!--  }-->

<!--</style>-->
<!--<body>-->
<!--<script src="//d3js.org/d3.v3.min.js"></script>-->
<!--<script>-->

<!--  var arc = d3.svg.arc()-->
<!--          .innerRadius(180)-->
<!--          .outerRadius(220)-->
<!--          .startAngle(0)-->
<!--          .endAngle(function(t) { return t * 2 * Math.PI / 3; });-->

<!--  var svg = d3.select("body").append("svg")-->
<!--          .attr("width", 960)-->
<!--          .attr("height", 500)-->
<!--          .append("g")-->
<!--          .attr("transform", "translate(480,250)");-->

<!--  svg.append("path")-->
<!--          .attr("id", "path")-->
<!--          .attr("d", arc(1));-->

<!--  svg.append("text")-->
<!--          .attr("x", 8)-->
<!--          .attr("dy", 28)-->
<!--          .append("textPath")-->
<!--          .attr("class", "textpath")-->
<!--          .attr("xlink:href", "#path")-->
<!--          .text("Hello, curved textPath!");-->

<!--  var transition = svg.transition()-->
<!--          .duration(5000);-->

<!--  transition.selectAll("#path")-->
<!--          .attrTween("d", function() { return arc; });-->

<!--  transition.selectAll(".textpath")-->
<!--          .attrTween("xlink:href", function() { return function() { return "#path"; }; });-->

<!--</script>-->

<!--plants.csv-->
<!--<!DOCTYPE html>-->
<!--<meta charset="utf-8">-->
<!--<style>-->

<!--  body {-->
<!--    background: #222;-->
<!--    position: relative;-->
<!--    text-align: center;-->
<!--  }-->

<!--  .system {-->
<!--    display: inline-block;-->
<!--    position: relative;-->
<!--    vertical-align: middle;-->
<!--  }-->

<!--  .orbit {-->
<!--    fill: none;-->
<!--    stroke: #ccc;-->
<!--    stroke-dasharray: 2,3;-->
<!--  }-->

<!--  .planet {-->
<!--    position: absolute;-->
<!--    top: 0;-->
<!--    left: 0;-->
<!--    -moz-animation-name: rotate;-->
<!--    -moz-animation-iteration-count: infinite;-->
<!--    -moz-animation-timing-function: linear;-->
<!--    -webkit-animation-name: rotate;-->
<!--    -webkit-animation-iteration-count: infinite;-->
<!--    -webkit-animation-timing-function: linear;-->
<!--    animation-name: rotate;-->
<!--    animation-iteration-count: infinite;-->
<!--    animation-timing-function: linear;-->
<!--  }-->

<!--  .planet circle {-->
<!--    fill: url(#planet-gradient);-->
<!--  }-->

<!--  @-moz-keyframes rotate {-->
<!--    from { -moz-transform: rotateZ(0deg); }-->
<!--    to { -moz-transform: rotateZ(-360deg); }-->
<!--  }-->

<!--  @-webkit-keyframes rotate {-->
<!--    from { -webkit-transform: rotateZ(0deg); }-->
<!--    to { -webkit-transform: rotateZ(-360deg); }-->
<!--  }-->

<!--  @keyframes rotate {-->
<!--    from { transform: rotateZ(0deg); }-->
<!--    to { transform: rotateZ(-360deg); }-->
<!--  }-->

<!--</style>-->
<!--<svg style="position:absolute;width:0;height:0;">-->
<!--  <defs>-->
<!--    <radialGradient id="planet-gradient" gradientUnits="objectBoundingBox" cx="50%" cy="50%" r="50%">-->
<!--      <stop offset="0%" stop-color="#aaa" stop-opacity="1"/>-->
<!--      <stop offset="100%" stop-color="#777" stop-opacity="1"/>-->
<!--    </radialGradient>-->
<!--  </defs>-->
<!--</svg>-->
<!--<script src="//d3js.org/d3.v3.min.js"></script>-->
<!--<script>-->

<!--  // Scales for semimajor axis, planet radius, and planet period.-->
<!--  var x = d3.scale.linear().range([0, 400]),-->
<!--          r = d3.scale.linear().domain([4, 40]).range([4 * .5, 40 * .5]).clamp(true),-->
<!--          t = d3.scale.linear().range([0, 1]);-->

<!--  var padding = 16;-->

<!--  // Detect the appropriate vendor prefix.-->
<!--  var prefix = "-webkit-transform" in document.body.style ? "-webkit-"-->
<!--          : "-moz-transform" in document.body.style ? "-moz-"-->
<!--                  : "";-->

<!--  d3.csv("planets.csv", type, function(error, planets) {-->
<!--    var systems = d3.nest()-->
<!--            .key(function(d) { return d.id; })-->
<!--            .entries(planets);-->

<!--    systems.forEach(function(s) {-->
<!--      s.values.forEach(function(p) { p.system = s; });-->
<!--      s.radius = d3.max(s.values, function(p) { return x(p.semimajor_axis) + r(p.planet_radius); }) + padding;-->
<!--    });-->

<!--    systems.sort(function(a, b) {-->
<!--      return a.radius - b.radius;-->
<!--    });-->

<!--    var system = d3.select("body").selectAll(".system")-->
<!--            .data(systems)-->
<!--            .enter().append("div")-->
<!--            .attr("class", "system")-->
<!--            .style("width", function(d) { return d.radius * 2 + "px"; })-->
<!--            .style("height", function(d) { return d.radius * 2 + "px"; });-->

<!--    system.append("svg")-->
<!--            .attr("class", "orbit")-->
<!--            .attr("width", function(d) { return d.radius * 2; })-->
<!--            .attr("height", function(d) { return d.radius * 2; })-->
<!--            .append("g")-->
<!--            .attr("transform", function(d) { return "translate(" + d.radius + "," + d.radius + ")"; })-->
<!--            .selectAll("circle")-->
<!--            .data(function(d) { return d.values; })-->
<!--            .enter().append("circle")-->
<!--            .attr("r", function(d) { return x(d.semimajor_axis); });-->

<!--    system.selectAll(".planet")-->
<!--            .data(function(d) { return d.values; })-->
<!--            .enter().append("svg")-->
<!--            .attr("class", "planet")-->
<!--            .attr("width", function(d) { return d.system.radius * 2; })-->
<!--            .attr("height", function(d) { return d.system.radius * 2; })-->
<!--            .style(prefix + "animation-duration", function(d) { return t(d.period) + "s"; })-->
<!--            .style(prefix + "transform-origin", function(d) { return d.system.radius + "px " + d.system.radius + "px"; })-->
<!--            .append("circle")-->
<!--            .attr("transform", function(d) { return "translate(" + d.system.radius + "," + d.system.radius + ")"; })-->
<!--            .attr("cx", function(d) { return x(d.semimajor_axis); })-->
<!--            .attr("r", function(d) { return r(d.planet_radius); });-->
<!--  });-->

<!--  function type(d) {-->
<!--    d.period = +d.period;-->
<!--    d.planet_radius = +d.planet_radius;-->
<!--    d.semimajor_axis = +d.semimajor_axis;-->
<!--    d.stellar_radius = +d.stellar_radius;-->
<!--    return d;-->
<!--  }-->

<!--</script>-->
<!--</body>-->
<!--</html>-->





<!--// Radius-->
<!--<!DOCTYPE html>-->
<!--<html lang="en">-->
<!--<head>-->
<!--    <meta charset="utf-8" />-->
<!--    <title>Mouse Spoke</title>-->
<!--    <link type="text/css" href="rotating_spoke.css" rel="stylesheet">-->
<!--    <script src="http://d3js.org/d3.v3.min.js"></script>-->
<!--</head>-->
<!--<body>-->
<!--<style>-->
<!--    svg {-->
<!--        background-color: #ddf;-->
<!--    }-->
<!--    #circle_01 {-->
<!--        fill: white;-->
<!--        fill-opacity: 0;-->
<!--        stroke: darkorchid;-->
<!--        stroke-width: 2;-->
<!--    }-->
<!--    #spoke_01 {-->
<!--        fill: none;-->
<!--        stroke: #602;-->
<!--        stroke-width: 2;-->
<!--        stroke-linecap: round;-->
<!--    }-->
<!--    #report {-->
<!--        fill: #602;-->
<!--        stroke: none;-->
<!--        font: 16pt sans-serif;-->
<!--    }-->
<!--</style>-->

<!--<script>-->

<!--    var w = 960,  h = 500 , r = 150;-->

<!--    var svg = d3.select("html").append("svg")-->
<!--        .attr({width: w, height: h})-->
<!--        .on("mousemove", follow_mouse);-->

<!--    var report = svg.append("text") .attr("id", "report")-->
<!--        .attr({x: 80, y: 80})-->
<!--        .text("Angle: 0.00°");-->

<!--    var g0 = svg.append("g").attr("id", "g0")-->
<!--        .attr("transform", "translate(" + [w/2, h/2] + ")");-->

<!--    var spoke_01 = g0.append("path") .attr("id", "spoke_01")-->
<!--        .attr("d", "M 0 0 h " + (r-2) + "l -9 3  2 -3 -2 -3 9 3");-->

<!--    var circle_01 = g0.append("circle").attr("id", "circle_01")-->
<!--        .attr("r", r);-->

<!--    function follow_mouse() {-->
<!--        var xy = d3.mouse(circle_01.node());-->
<!--        var angle = (180/Math.PI * Math.atan2(xy[1], xy[0]));-->
<!--        d3.select("#spoke_01").attr("transform", "rotate(" + angle + ")");-->
<!--        d3.select("#report").text("Angle: " + angle.toFixed(2) + "°");-->
<!--    }-->
<!--</script>-->
<!--</body>-->

<!--</html>-->






<!--Fine-grained control of randomly entering and exiting things in D3.js, for impeccable object constancy. Adapted from an example co-authored with Mike Bostock.-->

<!--<!DOCTYPE html>-->
<!--<html>-->
<!--<head>-->
<!--    <script src="http://d3js.org/d3.v3.min.js"></script>-->
<!--    <style>-->
<!--        html, body {-->
<!--            width: 100%;-->
<!--            height: 100%;-->
<!--            overflow: hidden;-->
<!--            margin: 0;-->
<!--            padding: 0;-->
<!--        }-->
<!--        circle {-->
<!--            fill: black;-->
<!--            stroke: none;-->
<!--        }-->
<!--        circle.saved {-->
<!--            fill: green;-->
<!--        }-->
<!--    </style>-->
<!--</head>-->
<!--<body>-->
<!--<script>-->

<!--    var w = 900,-->
<!--        h = 500,-->
<!--        svg = d3.select('body').append('svg')-->
<!--            .attr('width',w)-->
<!--            .attr('height',h);-->

<!--    var data = [],-->
<!--        removed = [];-->

<!--    function render() {-->

<!--        var circles = svg.selectAll('circle')-->
<!--            .data(data, function(d){-->
<!--                return d.id;-->
<!--            });-->

<!--        // the enter() selection needs representation:-->
<!--        circles.enter().append('circle')-->
<!--            .classed('entering',true)-->
<!--            .attr('cx',function(d){ return d.center.x; })-->
<!--            .attr('cy',function(d){ return d.center.y; })-->
<!--            .attr('r',100)-->
<!--            .style('opacity',1e-6);-->

<!--        // the exit() selection needs removing-->
<!--        circles.exit().filter(':not(.exiting)') // but only if we didn't already-->
<!--            .classed('exiting',true)-->
<!--            .transition().duration(1000)-->
<!--            .attr('r',100)-->
<!--            .style('opacity',1e-6)-->
<!--            .remove();-->

<!--        // just for debugging this demo, show which things were saved-->
<!--        // circles.classed('saved',function(d){ return d.saved; });-->

<!--        // two things here:-->
<!--        //  - if something is currently exiting (but in this selection),-->
<!--        //    we should cancel its exiting transition and restore it-->
<!--        //  - if something is currently entering (it was *just* added),-->
<!--        //    we need to trigger a brand new transition-->
<!--        circles.filter('.exiting, .entering')-->
<!--            .classed('exiting',false)-->
<!--            .classed('entering',false)-->
<!--            .transition().duration(1000)-->
<!--            .attr('r',function(d){ return d.radius; })-->
<!--            .style('opacity',1.0);-->

<!--        console.log(data.length)-->

<!--    }-->

<!--    setInterval(function(){-->
<!--        // remove a random element ever other tick (or so)-->
<!--        if (data.length > 20 && Math.random() > 0.5) {-->
<!--            var index = Math.floor(Math.random() * data.length);-->
<!--            var item = data[index];-->
<!--            data.splice(index,1);-->
<!--            // save 1 in 4 removed thing for later restoration-->
<!--            if (Math.random() < 0.25) {-->
<!--                item.saved = true;-->
<!--                removed.push(item);-->
<!--            }-->
<!--        } else {-->
<!--            // if we have something to save, save it:-->
<!--            if (removed.length) {-->
<!--                data.push(removed.pop());-->
<!--            } else {-->
<!--                // otherwise create a new one-->
<!--                data.push({-->
<!--                    id: new Date().getTime(),-->
<!--                    center: {-->
<!--                        x: Math.random() * w,-->
<!--                        y: Math.random() * h-->
<!--                    },-->
<!--                    radius: 2 + Math.random() * 10-->
<!--                });-->
<!--            }-->
<!--        }-->
<!--        render();-->
<!--    }, 30);-->

<!--</script>-->
<!--</body>-->

<!--</html>-->



<!--https://bost.ocks.org/mike/hive/-->
<!--<!DOCTYPE html>-->
<!--<meta charset="utf-8">-->
<!--<style>-->

<!--    .arc {-->
<!--        fill-opacity: .2;-->
<!--    }-->

<!--    .axis .fill {-->
<!--        stroke: #aaa;-->
<!--        stroke-width: 8px;-->
<!--        stroke-linecap: square;-->
<!--    }-->

<!--    .axis .stroke {-->
<!--        stroke: #fff;-->
<!--        stroke-width: 12px;-->
<!--        stroke-linecap: square;-->
<!--    }-->

<!--</style>-->
<!--<body>-->
<!--<script src="//d3js.org/d3.v3.min.js"></script>-->
<!--<script src="d3.hive.min.js"></script>-->
<!--<script>-->

<!--    var width = 960,-->
<!--        height = 500,-->
<!--        innerRadius = 40,-->
<!--        outerRadius = 240;-->

<!--    var angle = d3.scale.ordinal().domain(d3.range(4)).rangePoints([0, 2 * Math.PI]),-->
<!--        radius = d3.scale.linear().range([innerRadius, outerRadius]),-->
<!--        color = d3.scale.category20c().domain(d3.range(20));-->

<!--    var links = [-->
<!--        {source: {x: 0, y0: 0.9, y1: 1.0}, target: {x: 1, y0: 0.5, y1: 1.0}, group:  0},-->
<!--        {source: {x: 0, y0: 0.7, y1: 0.9}, target: {x: 1, y0: 0.4, y1: 0.5}, group:  1},-->
<!--        {source: {x: 0, y0: 0.4, y1: 0.7}, target: {x: 1, y0: 0.2, y1: 0.4}, group:  2},-->
<!--        {source: {x: 0, y0: 0.0, y1: 0.4}, target: {x: 1, y0: 0.0, y1: 0.2}, group:  3},-->
<!--        {source: {x: 1, y0: 0.8, y1: 1.0}, target: {x: 2, y0: 0.5, y1: 1.0}, group:  4},-->
<!--        {source: {x: 1, y0: 0.5, y1: 0.8}, target: {x: 2, y0: 0.2, y1: 0.5}, group:  5},-->
<!--        {source: {x: 1, y0: 0.3, y1: 0.5}, target: {x: 2, y0: 0.1, y1: 0.2}, group:  6},-->
<!--        {source: {x: 1, y0: 0.0, y1: 0.3}, target: {x: 2, y0: 0.0, y1: 0.1}, group:  7},-->
<!--        {source: {x: 2, y0: 0.8, y1: 1.0}, target: {x: 0, y0: 0.5, y1: 1.0}, group:  8},-->
<!--        {source: {x: 2, y0: 0.5, y1: 0.8}, target: {x: 0, y0: 0.2, y1: 0.5}, group:  9},-->
<!--        {source: {x: 2, y0: 0.1, y1: 0.5}, target: {x: 0, y0: 0.1, y1: 0.2}, group: 10},-->
<!--        {source: {x: 2, y0: 0.0, y1: 0.1}, target: {x: 0, y0: 0.0, y1: 0.1}, group: 11}-->
<!--    ];-->

<!--    var svg = d3.select("body").append("svg")-->
<!--        .attr("width", width)-->
<!--        .attr("height", height)-->
<!--        .append("g")-->
<!--        .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");-->

<!--    svg.selectAll(".link")-->
<!--        .data(links)-->
<!--        .enter().append("path")-->
<!--        .attr("class", "link")-->
<!--        .attr("d", d3.hive.link()-->
<!--            .angle(function(d) { return angle(d.x); })-->
<!--            .startRadius(function(d) { return radius(d.y0); })-->
<!--            .endRadius(function(d) { return radius(d.y1); }))-->
<!--        .style("fill", function(d) { return color(d.group); });-->

<!--    svg.selectAll(".axis")-->
<!--        .data(d3.range(3))-->
<!--        .enter().append("g")-->
<!--        .attr("class", "axis")-->
<!--        .attr("transform", function(d) { return "rotate(" + degrees(angle(d)) + ")"; })-->
<!--        .selectAll("line")-->
<!--        .data(["stroke", "fill"])-->
<!--        .enter().append("line")-->
<!--        .attr("class", function(d) { return d; })-->
<!--        .attr("x1", radius.range()[0])-->
<!--        .attr("x2", radius.range()[1]);-->

<!--    function degrees(radians) {-->
<!--        return radians / Math.PI * 180 - 90;-->
<!--    }-->

<!--</script>-->
<!--</body>-->
<!--</html>-->

<!--jQuery UI Resizable and Draggable with d3-->
<!--<!DOCTYPE html>-->

<!--<html lang="en">-->
<!--<head>-->
<!--    <meta charset="utf-8" />-->
<!--    <title>jQuery UI Resizable and Draggable with d3</title>-->
<!--    <link rel="stylesheet" href="http://code.jquery.com/ui/1.10.1/themes/base/jquery-ui.css" />-->
<!--    <script src="http://code.jquery.com/jquery-1.9.1.js"></script>-->
<!--    <script src="http://code.jquery.com/ui/1.10.1/jquery-ui.js"></script>-->
<!--    <script src="http://d3js.org/d3.v3.js"></script>-->
<!--    <link rel="stylesheet" href="http://code.jquery.com/ui/1.10.1/themes/base/jquery-ui.css" />-->
<!--    <style>-->
<!--        #resizable { width: 750px; height: 250px; padding: 0.5em; }-->
<!--        #resizable h3 { text-align: center; margin: 0; }-->
<!--        svg {-->
<!--            font: 10px sans-serif;-->
<!--        }-->

<!--        circle {-->
<!--            -webkit-transition: fill-opacity 250ms linear;-->
<!--        }-->

<!--        .selecting circle {-->
<!--            fill-opacity: .2;-->
<!--        }-->

<!--        .selecting circle.selected {-->
<!--            stroke: #f00;-->
<!--        }-->

<!--        .resize path {-->
<!--            fill: #666;-->
<!--            fill-opacity: .8;-->
<!--            stroke: #000;-->
<!--            stroke-width: 1.5px;-->
<!--        }-->

<!--        .axis path, .axis line {-->
<!--            fill: none;-->
<!--            stroke: #000;-->
<!--            shape-rendering: crispEdges;-->
<!--        }-->

<!--        .brush .extent {-->
<!--            fill-opacity: .125;-->
<!--            shape-rendering: crispEdges;-->
<!--        }-->

<!--    </style>-->
<!--</head>-->

<!--<body>-->
<!--<div id="resizable" class="ui-widget-content">-->
<!--    <h3 class="ui-widget-header">jQuery UI Resizable and Draggable with d3 Inside</h3>-->
<!--</div>-->
<!--<script>-->
<!--    //code references all listed below; each offered bits and pieces to this final work-->
<!--    //http://bl.ocks.org/mbostock/4349545 for the d3 chart-->
<!--    //http://jqueryui.com/resizable/#synchronous-resize-->
<!--    //https://gist.github.com/rduplain/2414111-->

<!--    $(document).ready(function () {-->

<!--        $(function () {-->
<!--            //add resizable functionality to the box-->
<!--            $("#resizable").resizable({-->
<!--                //when box is resized redraw the d3-->
<!--                stop: function (event, ui) {-->
<!--                    if (typeof Function === typeof draw_d3) {-->
<!--                        draw_d3("#resizable", data, ui.size.width, ui.size.height);-->
<!--                    }-->
<!--                }-->
<!--            });-->
<!--            //add default draggable functionality to the box-->
<!--            $("#resizable").draggable();-->
<!--        });-->

<!--        //generate random data to fill the graph-->
<!--        var data = d3.range(800).map(Math.random);-->

<!--        //initially draw the d3 chart with beginning dimensions of resizable box 750 and 250-->
<!--        draw_d3("#resizable", data, 750, 250);-->


<!--        //set up a function to draw the d3 graph-->
<!--        //we will separate this into a function so we can redraw with each resize-->
<!--        function draw_d3(reference, data, width, height) {-->

<!--            d3.select(reference).selectAll("svg").remove();-->

<!--            var margin = { top: 50, right: 50, bottom: 50, left: 50 },-->
<!--                width = width - margin.left - margin.right,-->
<!--                height = height - margin.top - margin.bottom;-->

<!--            var svg = d3.select(reference).append("svg")-->
<!--                .attr("width", width + margin.left + margin.right)-->
<!--                .attr("height", height + margin.top + margin.bottom)-->
<!--                .append("g")-->
<!--                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");-->

<!--            var x = d3.scale.linear()-->
<!--                .range([0, width]);-->

<!--            var y = d3.random.normal(height / 2, height / 8);-->

<!--            var brush = d3.svg.brush()-->
<!--                .x(x)-->
<!--                .extent([.3, .5])-->
<!--                .on("brushstart", brushstart)-->
<!--                .on("brush", brushmove)-->
<!--                .on("brushend", brushend);-->

<!--            var arc = d3.svg.arc()-->
<!--                .outerRadius(height / 2)-->
<!--                .startAngle(0)-->
<!--                .endAngle(function (d, i) { return i ? -Math.PI : Math.PI; });-->

<!--            svg.append("g")-->
<!--                .attr("class", "x axis")-->
<!--                .attr("transform", "translate(0," + height + ")")-->
<!--                .call(d3.svg.axis().scale(x).orient("bottom"));-->

<!--            var circle = svg.append("g").selectAll("circle")-->
<!--                .data(data)-->
<!--                .enter().append("circle")-->
<!--                .attr("transform", function (d) { return "translate(" + x(d) + "," + y() + ")"; })-->
<!--                .attr("r", 3.5);-->

<!--            var brushg = svg.append("g")-->
<!--                .attr("class", "brush")-->
<!--                .call(brush);-->

<!--            brushg.selectAll(".resize").append("path")-->
<!--                .attr("transform", "translate(0," + height / 2 + ")")-->
<!--                .attr("d", arc);-->

<!--            brushg.selectAll("rect")-->
<!--                .attr("height", height);-->

<!--            brushstart();-->
<!--            brushmove();-->

<!--            function brushstart() {-->
<!--                svg.classed("selecting", true);-->
<!--            }-->

<!--            function brushmove() {-->
<!--                var s = brush.extent();-->
<!--                circle.classed("selected", function (d) { return s[0] <= d && d <= s[1]; });-->
<!--            }-->

<!--            function brushend() {-->
<!--                svg.classed("selecting", !d3.event.target.empty());-->
<!--            }-->
<!--        }-->
<!--    });-->
<!-- </script>-->
<!--</body>-->
<!--</html>-->


<!--Mouseover to repel nodes. Adapted from my talk on force layouts. Compare to the canvas version.-->
<!--<!DOCTYPE html>-->
<!--<meta charset="utf-8">-->
<!--<body>-->
<!--<script src="//d3js.org/d3.v3.min.js"></script>-->
<!--<script>-->

<!--    var width = 960,-->
<!--        height = 500;-->

<!--    var nodes = d3.range(200).map(function() { return {radius: Math.random() * 12 + 4}; }),-->
<!--        root = nodes[0],-->
<!--        color = d3.scale.category10();-->

<!--    root.radius = 0;-->
<!--    root.fixed = true;-->

<!--    var force = d3.layout.force()-->
<!--        .gravity(0.05)-->
<!--        .charge(function(d, i) { return i ? 0 : -2000; })-->
<!--        .nodes(nodes)-->
<!--        .size([width, height]);-->

<!--    force.start();-->

<!--    var svg = d3.select("body").append("svg")-->
<!--        .attr("width", width)-->
<!--        .attr("height", height);-->

<!--    svg.selectAll("circle")-->
<!--        .data(nodes.slice(1))-->
<!--        .enter().append("circle")-->
<!--        .attr("r", function(d) { return d.radius; })-->
<!--        .style("fill", function(d, i) { return color(i % 3); });-->

<!--    force.on("tick", function(e) {-->
<!--        var q = d3.geom.quadtree(nodes),-->
<!--            i = 0,-->
<!--            n = nodes.length;-->

<!--        while (++i < n) q.visit(collide(nodes[i]));-->

<!--        svg.selectAll("circle")-->
<!--            .attr("cx", function(d) { return d.x; })-->
<!--            .attr("cy", function(d) { return d.y; });-->
<!--    });-->

<!--    svg.on("mousemove", function() {-->
<!--        var p1 = d3.mouse(this);-->
<!--        root.px = p1[0];-->
<!--        root.py = p1[1];-->
<!--        force.resume();-->
<!--    });-->

<!--    function collide(node) {-->
<!--        var r = node.radius + 16,-->
<!--            nx1 = node.x - r,-->
<!--            nx2 = node.x + r,-->
<!--            ny1 = node.y - r,-->
<!--            ny2 = node.y + r;-->
<!--        return function(quad, x1, y1, x2, y2) {-->
<!--            if (quad.point && (quad.point !== node)) {-->
<!--                var x = node.x - quad.point.x,-->
<!--                    y = node.y - quad.point.y,-->
<!--                    l = Math.sqrt(x * x + y * y),-->
<!--                    r = node.radius + quad.point.radius;-->
<!--                if (l < r) {-->
<!--                    l = (l - r) / l * .5;-->
<!--                    node.x -= x *= l;-->
<!--                    node.y -= y *= l;-->
<!--                    quad.point.x += x;-->
<!--                    quad.point.y += y;-->
<!--                }-->
<!--            }-->
<!--            return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;-->
<!--        };-->
<!--    }-->

<!--</script>-->
<!--</body>-->
<!--</html>-->

<!--This clustered force layout is implemented using two custom forces. The first, cluster, pushes nodes towards the largest node of the same color. A second collide force prevents circles from overlapping by detecting collisions.-->

<!--This example uses standard gravity; compare to custom gravity applied only to the largest node of each color. To minimize distracting jitter during initialization, try an entry transition.-->

<!--<!DOCTYPE html>-->
<!--<meta charset="utf-8">-->
<!--<body>-->
<!--<script src="//d3js.org/d3.v3.min.js"></script>-->
<!--<script>-->

<!--    var width = 960,-->
<!--        height = 500,-->
<!--        padding = 1.5, // separation between same-color circles-->
<!--        clusterPadding = 6, // separation between different-color circles-->
<!--        maxRadius = 12;-->

<!--    var n = 200, // total number of circles-->
<!--        m = 10; // number of distinct clusters-->

<!--    var color = d3.scale.category10()-->
<!--        .domain(d3.range(m));-->

<!--    // The largest node for each cluster.-->
<!--    var clusters = new Array(m);-->

<!--    var nodes = d3.range(n).map(function() {-->
<!--        var i = Math.floor(Math.random() * m),-->
<!--            r = Math.sqrt((i + 1) / m * -Math.log(Math.random())) * maxRadius,-->
<!--            d = {cluster: i, radius: r};-->
<!--        if (!clusters[i] || (r > clusters[i].radius)) clusters[i] = d;-->
<!--        return d;-->
<!--    });-->

<!--    var force = d3.layout.force()-->
<!--        .nodes(nodes)-->
<!--        .size([width, height])-->
<!--        .gravity(.02)-->
<!--        .charge(0)-->
<!--        .on("tick", tick)-->
<!--        .start();-->

<!--    var svg = d3.select("body").append("svg")-->
<!--        .attr("width", width)-->
<!--        .attr("height", height);-->

<!--    var circle = svg.selectAll("circle")-->
<!--        .data(nodes)-->
<!--        .enter().append("circle")-->
<!--        .attr("r", function(d) { return d.radius; })-->
<!--        .style("fill", function(d) { return color(d.cluster); })-->
<!--        .call(force.drag);-->

<!--    function tick(e) {-->
<!--        circle-->
<!--            .each(cluster(10 * e.alpha * e.alpha))-->
<!--            .each(collide(.5))-->
<!--            .attr("cx", function(d) { return d.x; })-->
<!--            .attr("cy", function(d) { return d.y; });-->
<!--    }-->

<!--    // Move d to be adjacent to the cluster node.-->
<!--    function cluster(alpha) {-->
<!--        return function(d) {-->
<!--            var cluster = clusters[d.cluster];-->
<!--            if (cluster === d) return;-->
<!--            var x = d.x - cluster.x,-->
<!--                y = d.y - cluster.y,-->
<!--                l = Math.sqrt(x * x + y * y),-->
<!--                r = d.radius + cluster.radius;-->
<!--            if (l != r) {-->
<!--                l = (l - r) / l * alpha;-->
<!--                d.x -= x *= l;-->
<!--                d.y -= y *= l;-->
<!--                cluster.x += x;-->
<!--                cluster.y += y;-->
<!--            }-->
<!--        };-->
<!--    }-->

<!--    // Resolves collisions between d and all other circles.-->
<!--    function collide(alpha) {-->
<!--        var quadtree = d3.geom.quadtree(nodes);-->
<!--        return function(d) {-->
<!--            var r = d.radius + maxRadius + Math.max(padding, clusterPadding),-->
<!--                nx1 = d.x - r,-->
<!--                nx2 = d.x + r,-->
<!--                ny1 = d.y - r,-->
<!--                ny2 = d.y + r;-->
<!--            quadtree.visit(function(quad, x1, y1, x2, y2) {-->
<!--                if (quad.point && (quad.point !== d)) {-->
<!--                    var x = d.x - quad.point.x,-->
<!--                        y = d.y - quad.point.y,-->
<!--                        l = Math.sqrt(x * x + y * y),-->
<!--                        r = d.radius + quad.point.radius + (d.cluster === quad.point.cluster ? padding : clusterPadding);-->
<!--                    if (l < r) {-->
<!--                        l = (l - r) / l * alpha;-->
<!--                        d.x -= x *= l;-->
<!--                        d.y -= y *= l;-->
<!--                        quad.point.x += x;-->
<!--                        quad.point.y += y;-->
<!--                    }-->
<!--                }-->
<!--                return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;-->
<!--            });-->
<!--        };-->
<!--    }-->

<!--</script>-->
<!--</body>-->
<!--</html>-->

<!--ring-->
<!--2 circles-->
<!--<!DOCTYPE html>-->
<!--<meta charset="utf-8">-->
<!--<body>-->
<!--<script src="//d3js.org/d3.v3.min.js"></script>-->
<!--<script>-->

<!--    var svg = d3.select("body").append("svg")-->
<!--        .attr("width", 960)-->
<!--        .attr("height", 500)-->
<!--        .append("g")-->
<!--        .attr("transform", "translate(480,250)");-->

<!--    var g = svg.selectAll("g")-->
<!--        .data(d3.range(0, 360, 2))-->
<!--        .enter().append("g")-->
<!--        .attr("transform", function(d) { return "rotate(" + d + ")"; });-->

<!--    var circle = g.selectAll("circle")-->
<!--        .data(d3.range(10))-->
<!--        .enter().append("circle")-->
<!--        .attr("cx", d3.scale.linear().domain([0, 9]).range([180, 240]))-->
<!--        .attr("r", 4.5)-->
<!--        .attr("fill", d3.scale.linear().domain([0, 9]).range(["brown", "steelblue"]))-->
<!--        .attr("stroke", "black");-->

<!--</script>-->




<!--ring with draggable inputs and brightness adjustment-->
<!--<!DOCTYPE html>-->
<!--<meta charset="utf-8">-->
<!--<style>-->

<!--    body {-->
<!--        background: #333;-->
<!--    }-->

<!--    input {-->
<!--        position: absolute;-->
<!--        left: 8px;-->
<!--        top: 8px;-->
<!--        width: 240px;-->
<!--    }-->

<!--</style>-->
<!--<input type="range" min="0" max="358" step="2">-->
<!--<script src="//d3js.org/d3.v3.min.js"></script>-->
<!--<script>-->

<!--    var radius = d3.scale.linear()-->
<!--        .domain([0, 9])-->
<!--        .range([120, 240]);-->

<!--    var fill = d3.scale.linear()-->
<!--        .domain([0, 1])-->
<!--        .range(["brown", "steelblue"]);-->

<!--    var svg = d3.select("body").append("svg")-->
<!--        .attr("width", 960)-->
<!--        .attr("height", 500)-->
<!--        .append("g")-->
<!--        .attr("transform", "translate(480,250)");-->

<!--    var g = svg.selectAll("g")-->
<!--        .data(d3.range(0, 360, 2))-->
<!--        .enter().append("g")-->
<!--        .attr("transform", function(d) { return "rotate(" + d + ")"; });-->

<!--    var path = g.selectAll("path")-->
<!--        .data(function(p) {-->
<!--            return d3.range(10).map(function(d) {-->
<!--                return {-->
<!--                    x: p, // outer dimension (angle)-->
<!--                    y: d, // inner dimension (radius)-->
<!--                    z: Math.random()-->
<!--                };-->
<!--            });-->
<!--        })-->
<!--        .enter().append("path")-->
<!--        .attr("d", d3.svg.arc()-->
<!--            .innerRadius(function(d) { return radius(d.y); })-->
<!--            .outerRadius(function(d) { return radius(d.y + 1); })-->
<!--            .startAngle(0)-->
<!--            .endAngle(Math.PI / 90))-->
<!--        .attr("fill", function(d) { return fill(d.z); })-->
<!--        .attr("fill-opacity", 1e-6);-->

<!--    path.transition()-->
<!--        .delay(function(d) { return d.z * 1500; })-->
<!--        .attr("fill-opacity", 1);-->

<!--    d3.select("input")-->
<!--        .on("input", changed)-->
<!--        .on("change", changed);-->

<!--    function changed() {-->
<!--        var value = this.value;-->
<!--        path.attr("fill-opacity", function(d) {-->
<!--            return Math.max(0, 1 - Math.sqrt(Math.abs(d.x - value) / 80));-->
<!--        });-->
<!--    }-->

<!--</script>-->






<!--Drag the control points of the polygon to see whether the polygon intersects with the circle.-->

<!--<!DOCTYPE html>-->
<!--<meta charset="utf-8">-->
<!--<style>-->

<!--    .circle {-->
<!--        fill: red;-->
<!--        fill-opacity: .3;-->
<!--    }-->

<!--    .circle.intersects {-->
<!--        fill: green;-->
<!--    }-->

<!--    .polygon path {-->
<!--        fill: #000;-->
<!--        fill-opacity: .3;-->
<!--    }-->

<!--    .polygon circle {-->
<!--        fill: #000;-->
<!--        stroke: #fff;-->
<!--        cursor: move;-->
<!--    }-->

<!--</style>-->
<!--<body>-->
<!--<script src="//d3js.org/d3.v3.min.js"></script>-->
<!--<script>-->

<!--    var width = 960,-->
<!--        height = 500;-->

<!--    var svg = d3.select("body").append("svg")-->
<!--        .attr("width", width)-->
<!--        .attr("height", height);-->

<!--    var circle = svg.append("circle")-->
<!--        .attr("class", "circle intersects")-->
<!--        .datum([width / 2, height / 2, 120])-->
<!--        .call(positionCircle)-->
<!--        .attr("r", function(d) { return d[2]; });-->

<!--    var polygon = svg.append("g")-->
<!--        .attr("class", "polygon")-->
<!--        .datum([[500, 300], [600, 300], [600, 400], [500, 400]]);-->

<!--    polygon.append("path")-->
<!--        .call(positionPath);-->

<!--    polygon.selectAll("circle")-->
<!--        .data(function(d) { return d; })-->
<!--        .enter().append("circle")-->
<!--        .call(positionCircle)-->
<!--        .attr("r", 4.5)-->
<!--        .call(d3.behavior.drag()-->
<!--            .origin(function(d) { return {x: d[0], y: d[1]}; })-->
<!--            .on("drag", function(d) {-->
<!--                d[0] = d3.event.x, d[1] = d3.event.y;-->
<!--                d3.select(this).call(positionCircle);-->
<!--                polygon.select("path").call(positionPath);-->
<!--                circle.classed("intersects", intersects(circle.datum(), polygon.datum()));-->
<!--            }));-->

<!--    function positionCircle(circle) {-->
<!--        circle-->
<!--            .attr("cx", function(d) { return d[0]; })-->
<!--            .attr("cy", function(d) { return d[1]; });-->
<!--    }-->

<!--    function positionPath(path) {-->
<!--        path-->
<!--            .attr("d", function(d) { return "M" + d.join("L") + "Z"; });-->
<!--    }-->

<!--    function intersects(circle, polygon) {-->
<!--        return pointInPolygon(circle, polygon)-->
<!--            || polygonEdges(polygon).some(function(line) { return pointLineSegmentDistance(circle, line) < circle[2]; });-->
<!--    }-->

<!--    function polygonEdges(polygon) {-->
<!--        return polygon.map(function(p, i) {-->
<!--            return i ? [polygon[i - 1], p] : [polygon[polygon.length - 1], p];-->
<!--        });-->
<!--    }-->

<!--    function pointInPolygon(point, polygon) {-->
<!--        for (var n = polygon.length, i = 0, j = n - 1, x = point[0], y = point[1], inside = false; i < n; j = i++) {-->
<!--            var xi = polygon[i][0], yi = polygon[i][1],-->
<!--                xj = polygon[j][0], yj = polygon[j][1];-->
<!--            if ((yi > y ^ yj > y) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) inside = !inside;-->
<!--        }-->
<!--        return inside;-->
<!--    }-->

<!--    function pointLineSegmentDistance(point, line) {-->
<!--        var v = line[0], w = line[1], d, t;-->
<!--        return Math.sqrt(pointPointSquaredDistance(point, (d = pointPointSquaredDistance(v, w))-->
<!--            ? ((t = ((point[0] - v[0]) * (w[0] - v[0]) + (point[1] - v[1]) * (w[1] - v[1])) / d) < 0 ? v-->
<!--                : t > 1 ? w-->
<!--                    : [v[0] + t * (w[0] - v[0]), v[1] + t * (w[1] - v[1])])-->
<!--            : v));-->
<!--    }-->

<!--    function pointPointSquaredDistance(v, w) {-->
<!--        var dx = v[0] - w[0], dy = v[1] - w[1];-->
<!--        return dx * dx + dy * dy;-->
<!--    }-->

<!--</script>-->



<!--circos-->
<!--<!DOCTYPE html>-->
<!--<meta charset="utf-8">-->
<!--<style>-->

<!--    body {-->
<!--        font: 10px sans-serif;-->
<!--    }-->

<!--    .group-tick line {-->
<!--        stroke: #000;-->
<!--    }-->

<!--    .ribbons {-->
<!--        fill-opacity: 0.67;-->
<!--    }-->

<!--</style>-->
<!--<svg width="960" height="960"></svg>-->
<!--<script src="https://d3js.org/d3.v4.min.js"></script>-->
<!--<script>-->

<!--    var matrix = [-->
<!--        [11975,  5871, 8916, 2868],-->
<!--        [ 1951, 10048, 2060, 6171],-->
<!--        [ 8010, 16145, 8090, 8045],-->
<!--        [ 1013,   990,  940, 6907]-->
<!--    ];-->

<!--    var svg = d3.select("svg"),-->
<!--        width = +svg.attr("width"),-->
<!--        height = +svg.attr("height"),-->
<!--        outerRadius = Math.min(width, height) * 0.5 - 40,-->
<!--        innerRadius = outerRadius - 30;-->

<!--    var formatValue = d3.formatPrefix(",.0", 1e3);-->

<!--    var chord = d3.chord()-->
<!--        .padAngle(0.05)-->
<!--        .sortSubgroups(d3.descending);-->

<!--    var arc = d3.arc()-->
<!--        .innerRadius(innerRadius)-->
<!--        .outerRadius(outerRadius);-->

<!--    var ribbon = d3.ribbon()-->
<!--        .radius(innerRadius);-->

<!--    var color = d3.scaleOrdinal()-->
<!--        .domain(d3.range(4))-->
<!--        .range(["#000000", "#FFDD89", "#957244", "#F26223"]);-->

<!--    var g = svg.append("g")-->
<!--        .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")-->
<!--        .datum(chord(matrix));-->

<!--    var group = g.append("g")-->
<!--        .attr("class", "groups")-->
<!--        .selectAll("g")-->
<!--        .data(function(chords) { return chords.groups; })-->
<!--        .enter().append("g");-->

<!--    group.append("path")-->
<!--        .style("fill", function(d) { return color(d.index); })-->
<!--        .style("stroke", function(d) { return d3.rgb(color(d.index)).darker(); })-->
<!--        .attr("d", arc);-->

<!--    var groupTick = group.selectAll(".group-tick")-->
<!--        .data(function(d) { return groupTicks(d, 1e3); })-->
<!--        .enter().append("g")-->
<!--        .attr("class", "group-tick")-->
<!--        .attr("transform", function(d) { return "rotate(" + (d.angle * 180 / Math.PI - 90) + ") translate(" + outerRadius + ",0)"; });-->

<!--    groupTick.append("line")-->
<!--        .attr("x2", 6);-->

<!--    groupTick-->
<!--        .filter(function(d) { return d.value % 5e3 === 0; })-->
<!--        .append("text")-->
<!--        .attr("x", 8)-->
<!--        .attr("dy", ".35em")-->
<!--        .attr("transform", function(d) { return d.angle > Math.PI ? "rotate(180) translate(-16)" : null; })-->
<!--        .style("text-anchor", function(d) { return d.angle > Math.PI ? "end" : null; })-->
<!--        .text(function(d) { return formatValue(d.value); });-->

<!--    g.append("g")-->
<!--        .attr("class", "ribbons")-->
<!--        .selectAll("path")-->
<!--        .data(function(chords) { return chords; })-->
<!--        .enter().append("path")-->
<!--        .attr("d", ribbon)-->
<!--        .style("fill", function(d) { return color(d.target.index); })-->
<!--        .style("stroke", function(d) { return d3.rgb(color(d.target.index)).darker(); });-->

<!--    // Returns an array of tick angles and values for a given group and step.-->
<!--    function groupTicks(d, step) {-->
<!--        var k = (d.endAngle - d.startAngle) / d.value;-->
<!--        return d3.range(0, d.value, step).map(function(value) {-->
<!--            return {value: value, angle: value * k + d.startAngle};-->
<!--        });-->
<!--    }-->

<!--</script>-->


<!--star-->
<!--<!DOCTYPE html>-->
<!--<meta charset="utf-8">-->
<!--<style>-->

<!--    body {-->
<!--        background: #fcfcfa;-->
<!--    }-->

<!--    .stroke {-->
<!--        fill: none;-->
<!--        stroke: #000;-->
<!--        stroke-width: 3px;-->
<!--    }-->

<!--    .fill {-->
<!--        fill: #fff;-->
<!--    }-->

<!--    .graticule {-->
<!--        fill: none;-->
<!--        stroke: #777;-->
<!--        stroke-width: .5px;-->
<!--        stroke-opacity: .5;-->
<!--    }-->

<!--    .land {-->
<!--        fill: #222;-->
<!--    }-->

<!--    .boundary {-->
<!--        fill: none;-->
<!--        stroke: #fff;-->
<!--        stroke-width: .5px;-->
<!--    }-->

<!--</style>-->
<!--<body>-->
<!--<script src="//d3js.org/d3.v3.min.js"></script>-->
<!--<script src="//d3js.org/d3.geo.projection.v0.min.js"></script>-->
<!--<script src="//d3js.org/topojson.v1.min.js"></script>-->
<!--<script>-->

<!--    var width = 960,-->
<!--        height = 900;-->

<!--    var projection = d3.geo.berghaus()-->
<!--        .rotate([20, -90])-->
<!--        .clipAngle(180 - 1e-3)-->
<!--        .scale(155)-->
<!--        .translate([width / 2, height * .55])-->
<!--        .precision(.1);-->

<!--    var path = d3.geo.path()-->
<!--        .projection(projection);-->

<!--    var graticule = d3.geo.graticule();-->

<!--    var svg = d3.select("body").append("svg")-->
<!--        .attr("width", width)-->
<!--        .attr("height", height);-->

<!--    var defs = svg.append("defs");-->

<!--    defs.append("path")-->
<!--        .datum({type: "Sphere"})-->
<!--        .attr("id", "sphere")-->
<!--        .attr("d", path);-->

<!--    defs.append("clipPath")-->
<!--        .attr("id", "clip")-->
<!--        .append("use")-->
<!--        .attr("xlink:href", "#sphere");-->

<!--    svg.append("use")-->
<!--        .attr("class", "stroke")-->
<!--        .attr("xlink:href", "#sphere");-->

<!--    svg.append("use")-->
<!--        .attr("class", "fill")-->
<!--        .attr("xlink:href", "#sphere");-->

<!--    svg.append("path")-->
<!--        .datum(graticule)-->
<!--        .attr("class", "graticule")-->
<!--        .attr("clip-path", "url(#clip)")-->
<!--        .attr("d", path);-->

<!--    d3.json("/mbostock/raw/4090846/world-50m.json", function(error, world) {-->
<!--        if (error) throw error;-->

<!--        svg.insert("path", ".graticule")-->
<!--            .datum(topojson.feature(world, world.objects.land))-->
<!--            .attr("class", "land")-->
<!--            .attr("clip-path", "url(#clip)")-->
<!--            .attr("d", path);-->

<!--        svg.insert("path", ".graticule")-->
<!--            .datum(topojson.mesh(world, world.objects.countries, function(a, b) { return a !== b; }))-->
<!--            .attr("class", "boundary")-->
<!--            .attr("clip-path", "url(#clip)")-->
<!--            .attr("d", path);-->
<!--    });-->

<!--    d3.select(self.frameElement).style("height", height + "px");-->

<!--</script>-->




<!--circle enter and exit-->
<!--<!DOCTYPE html>-->
<!--<meta charset="utf-8">-->
<!--<body>-->
<!--<script src="//d3js.org/d3.v3.min.js"></script>-->
<!--<script>-->

<!--    var width = 960,-->
<!--        height = 500;-->

<!--    var x = d3.scale.ordinal()-->
<!--        .domain([0, 1, 2])-->
<!--        .rangePoints([0, width], 1);-->

<!--    var svg = d3.select("body").append("svg")-->
<!--        .attr("width", width)-->
<!--        .attr("height", height);-->

<!--    var circle = svg.selectAll("circle")-->
<!--        .data([0, 1])-->
<!--        .enter().append("circle")-->
<!--        .attr("r", height / 4)-->
<!--        .attr("cx", x)-->
<!--        .attr("cy", height / 2);-->

<!--    setTimeout(function() {-->
<!--        circle = circle.data([1, 2], function(d) { return d; });-->

<!--        // Since this is created before enter.append, it only applies to updating nodes.-->
<!--        circle.transition()-->
<!--            .duration(750)-->
<!--            .attr("r", height / 3)-->
<!--            .style("fill", "orange");-->

<!--        circle.enter().append("circle")-->
<!--            .attr("r", height / 4)-->
<!--            .attr("cx", x)-->
<!--            .attr("cy", height / 2)-->
<!--            .style("fill", "green");-->

<!--        circle.exit().transition()-->
<!--            .duration(750)-->
<!--            .style("fill", "red")-->
<!--            .attr("r", 1e-6)-->
<!--            .remove();-->

<!--    }, 1000);-->

<!--</script>-->


<!--circle text moving-->
<!--<!DOCTYPE html>-->
<!--<meta charset="utf-8">-->
<!--<style>-->

<!--    text {-->
<!--        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;-->
<!--    }-->

<!--    circle {-->
<!--        fill: none;-->
<!--        stroke: #000;-->
<!--        stroke-width: 1.5px;-->
<!--    }-->

<!--</style>-->
<!--<body>-->
<!--<script src="//d3js.org/d3.v3.min.js"></script>-->
<!--<script>-->

<!--    var width = 480,-->
<!--        height = 500;-->

<!--    var svg = d3.select("body").selectAll("svg")-->
<!--        .data(["interpolateTransform", "interpolateString"])-->
<!--        .enter().append("svg")-->
<!--        .attr("width", width)-->
<!--        .attr("height", height)-->
<!--        .append("g")-->
<!--        .attr("transform", "translate(240,250)");-->

<!--    svg.append("circle")-->
<!--        .attr("r", 100);-->

<!--    svg.append("text")-->
<!--        .attr("dy", "-.3em")-->
<!--        .attr("text-anchor", "middle")-->
<!--        .text(String)-->
<!--        .each(cycle);-->

<!--    function cycle(d) {-->
<!--        d3.select(this).transition()-->
<!--            .duration(4000)-->
<!--            .attrTween("transform", function(interpolate) {-->
<!--                return d3[interpolate](-->
<!--                    "rotate(180)translate(0,-100)",-->
<!--                    "rotate(360)translate(0,-100)"-->
<!--                );-->
<!--            })-->
<!--            .each("end", cycle);-->
<!--    }-->

<!--</script>-->


<!--pie chart transition-->
<!--<!DOCTYPE html>-->
<!--<meta charset="utf-8">-->
<!--<title>Pie Chart</title>-->
<!--<body>-->
<!--<script src="//d3js.org/d3.v3.min.js"></script>-->
<!--<script>-->

<!--    var width = 960,-->
<!--        height = 500,-->
<!--        radius = Math.min(width, height) / 2 - 10;-->

<!--    var data = d3.range(10).map(Math.random).sort(d3.descending);-->

<!--    var color = d3.scale.category20();-->

<!--    var arc = d3.svg.arc()-->
<!--        .outerRadius(radius);-->

<!--    var pie = d3.layout.pie();-->

<!--    var svg = d3.select("body").append("svg")-->
<!--        .datum(data)-->
<!--        .attr("width", width)-->
<!--        .attr("height", height)-->
<!--        .append("g")-->
<!--        .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");-->

<!--    var arcs = svg.selectAll("g.arc")-->
<!--        .data(pie)-->
<!--        .enter().append("g")-->
<!--        .attr("class", "arc");-->

<!--    arcs.append("path")-->
<!--        .attr("fill", function(d, i) { return color(i); })-->
<!--        .transition()-->
<!--        .ease("bounce")-->
<!--        .duration(2000)-->
<!--        .attrTween("d", tweenPie)-->
<!--        .transition()-->
<!--        .ease("elastic")-->
<!--        .delay(function(d, i) { return 2000 + i * 50; })-->
<!--        .duration(750)-->
<!--        .attrTween("d", tweenDonut);-->

<!--    function tweenPie(b) {-->
<!--        b.innerRadius = 0;-->
<!--        var i = d3.interpolate({startAngle: 0, endAngle: 0}, b);-->
<!--        return function(t) { return arc(i(t)); };-->
<!--    }-->

<!--    function tweenDonut(b) {-->
<!--        b.innerRadius = radius * .6;-->
<!--        var i = d3.interpolate({innerRadius: 0}, b);-->
<!--        return function(t) { return arc(i(t)); };-->
<!--    }-->

<!--</script>-->




<!--draw line-->
<!--<!DOCTYPE html>-->
<!--<meta charset="utf-8">-->
<!--<body>-->
<!--<style>-->

<!--    path {-->
<!--        fill: none;-->
<!--        stroke: #000;-->
<!--        stroke-width: 3px;-->
<!--    }-->

<!--</style>-->
<!--<script src="//d3js.org/d3.v3.min.js"></script>-->
<!--<script>-->

<!--    var points = [-->
<!--        [480, 200],-->
<!--        [580, 400],-->
<!--        [680, 100],-->
<!--        [780, 300],-->
<!--        [180, 300],-->
<!--        [280, 100],-->
<!--        [380, 400]-->
<!--    ];-->

<!--    var line = d3.svg.line()-->
<!--        .tension(0) // Catmull–Rom-->
<!--        .interpolate("cardinal-closed");-->

<!--    var svg = d3.select("body").append("svg")-->
<!--        .datum(points)-->
<!--        .attr("width", 960)-->
<!--        .attr("height", 500);-->

<!--    svg.append("path")-->
<!--        .style("stroke", "#ddd")-->
<!--        .style("stroke-dasharray", "4,4")-->
<!--        .attr("d", line);-->

<!--    svg.append("path")-->
<!--        .attr("d", line)-->
<!--        .call(transition);-->

<!--    function transition(path) {-->
<!--        path.transition()-->
<!--            .duration(7500)-->
<!--            .attrTween("stroke-dasharray", tweenDash)-->
<!--            .each("end", function() { d3.select(this).call(transition); });-->
<!--    }-->

<!--    function tweenDash() {-->
<!--        var l = this.getTotalLength(),-->
<!--            i = d3.interpolateString("0," + l, l + "," + l);-->
<!--        return function(t) { return i(t); };-->
<!--    }-->

<!--</script>-->


<!--donut chart trends-->
<!--<!DOCTYPE html>-->
<!--<meta charset="utf-8">-->
<!--<style>-->

<!--    body {-->
<!--        font: 10px sans-serif;-->
<!--    }-->

<!--    .axis line {-->
<!--        stroke: #000;-->
<!--    }-->

<!--    .axis path {-->
<!--        fill: none;-->
<!--        stroke: #000;-->
<!--    }-->

<!--    .axis + .axis g text {-->
<!--        display: none;-->
<!--    }-->

<!--</style>-->
<!--<body>-->
<!--<script src="//d3js.org/d3.v3.min.js"></script>-->
<!--<script>-->

<!--    var formatDate = d3.time.format("%a"),-->
<!--        formatDay = function(d) { return formatDate(new Date(2007, 0, d)); };-->

<!--    var width = 960,-->
<!--        height = 500,-->
<!--        outerRadius = height / 2 - 10,-->
<!--        innerRadius = 120;-->

<!--    var angle = d3.time.scale()-->
<!--        .range([0, 2 * Math.PI]);-->

<!--    var radius = d3.scale.linear()-->
<!--        .range([innerRadius, outerRadius]);-->

<!--    var z = d3.scale.category20c();-->

<!--    var stack = d3.layout.stack()-->
<!--        .offset("zero")-->
<!--        .values(function(d) { return d.values; })-->
<!--        .x(function(d) { return d.time; })-->
<!--        .y(function(d) { return d.value; });-->

<!--    var nest = d3.nest()-->
<!--        .key(function(d) { return d.key; });-->

<!--    var line = d3.svg.line.radial()-->
<!--        .interpolate("cardinal-closed")-->
<!--        .angle(function(d) { return angle(d.time); })-->
<!--        .radius(function(d) { return radius(d.y0 + d.y); });-->

<!--    var area = d3.svg.area.radial()-->
<!--        .interpolate("cardinal-closed")-->
<!--        .angle(function(d) { return angle(d.time); })-->
<!--        .innerRadius(function(d) { return radius(d.y0); })-->
<!--        .outerRadius(function(d) { return radius(d.y0 + d.y); });-->

<!--    var svg = d3.select("body").append("svg")-->
<!--        .attr("width", width)-->
<!--        .attr("height", height)-->
<!--        .append("g")-->
<!--        .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");-->

<!--    d3.csv("data.csv", type, function(error, data) {-->
<!--        if (error) throw error;-->

<!--        var layers = stack(nest.entries(data));-->

<!--        // Extend the domain slightly to match the range of [0, 2π].-->
<!--        angle.domain([0, d3.max(data, function(d) { return d.time + 1; })]);-->
<!--        radius.domain([0, d3.max(data, function(d) { return d.y0 + d.y; })]);-->

<!--        svg.selectAll(".layer")-->
<!--            .data(layers)-->
<!--            .enter().append("path")-->
<!--            .attr("class", "layer")-->
<!--            .attr("d", function(d) { return area(d.values); })-->
<!--            .style("fill", function(d, i) { return z(i); });-->

<!--        svg.selectAll(".axis")-->
<!--            .data(d3.range(angle.domain()[1]))-->
<!--            .enter().append("g")-->
<!--            .attr("class", "axis")-->
<!--            .attr("transform", function(d) { return "rotate(" + angle(d) * 180 / Math.PI + ")"; })-->
<!--            .call(d3.svg.axis()-->
<!--                .scale(radius.copy().range([-innerRadius, -outerRadius]))-->
<!--                .orient("left"))-->
<!--            .append("text")-->
<!--            .attr("y", -innerRadius + 6)-->
<!--            .attr("dy", ".71em")-->
<!--            .attr("text-anchor", "middle")-->
<!--            .text(function(d) { return formatDay(d); });-->
<!--    });-->

<!--    function type(d) {-->
<!--        d.time = +d.time;-->
<!--        d.value = +d.value;-->
<!--        return d;-->
<!--    }-->

<!--</script>-->



<!--<!DOCTYPE html>-->
<!--<meta charset="utf-8">-->
<!--<style>-->

<!--    body {-->
<!--        background: #222;-->
<!--        margin: auto;-->
<!--        width: 960px;-->
<!--    }-->

<!--    .arc-text {-->
<!--        font: 16px sans-serif;-->
<!--    }-->

<!--    .arc-center {-->
<!--        fill: none;-->
<!--    }-->

<!--    #credit {-->
<!--        position: absolute;-->
<!--        font: 10px sans-serif;-->
<!--        right: 10px;-->
<!--        bottom: 10px;-->
<!--        color: #ddd;-->
<!--    }-->

<!--    #credit a {-->
<!--        color: inherit;-->
<!--    }-->

<!--</style>-->
<!--<div id="credit">Inspired by <a href="http://blog.pixelbreaker.com/polarclock/">pixelbreaker</a>.</div>-->
<!--<script src="//d3js.org/d3.v3.min.js"></script>-->
<!--<script>-->

<!--    var width = 960,-->
<!--        height = 800,-->
<!--        radius = Math.min(width, height) / 1.9,-->
<!--        spacing = .09;-->

<!--    var formatSecond = d3.time.format("%-S seconds"),-->
<!--        formatMinute = d3.time.format("%-M minutes"),-->
<!--        formatHour = d3.time.format("%-H hours"),-->
<!--        formatDay = d3.time.format("%A"),-->
<!--        formatDate = function(d) { d = d.getDate(); switch (10 <= d && d <= 19 ? 10 : d % 10) { case 1: d += "st"; break; case 2: d += "nd"; break; case 3: d += "rd"; break; default: d += "th"; break; } return d; },-->
<!--        formatMonth = d3.time.format("%B");-->

<!--    var color = d3.scale.linear()-->
<!--        .range(["hsl(-180,60%,50%)", "hsl(180,60%,50%)"])-->
<!--        .interpolate(function(a, b) { var i = d3.interpolateString(a, b); return function(t) { return d3.hsl(i(t)); }; });-->

<!--    var arcBody = d3.svg.arc()-->
<!--        .startAngle(0)-->
<!--        .endAngle(function(d) { return d.value * 2 * Math.PI; })-->
<!--        .innerRadius(function(d) { return d.index * radius; })-->
<!--        .outerRadius(function(d) { return (d.index + spacing) * radius; })-->
<!--        .cornerRadius(6);-->

<!--    var arcCenter = d3.svg.arc()-->
<!--        .startAngle(0)-->
<!--        .endAngle(function(d) { return d.value * 2 * Math.PI; })-->
<!--        .innerRadius(function(d) { return (d.index + spacing / 2) * radius; })-->
<!--        .outerRadius(function(d) { return (d.index + spacing / 2) * radius; });-->

<!--    var svg = d3.select("body").append("svg")-->
<!--        .attr("width", width)-->
<!--        .attr("height", height)-->
<!--        .append("g")-->
<!--        .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");-->

<!--    var field = svg.selectAll("g")-->
<!--        .data(fields)-->
<!--        .enter().append("g");-->

<!--    field.append("path")-->
<!--        .attr("class", "arc-body");-->

<!--    field.append("path")-->
<!--        .attr("id", function(d, i) { return "arc-center-" + i; })-->
<!--        .attr("class", "arc-center");-->

<!--    field.append("text")-->
<!--        .attr("dy", ".35em")-->
<!--        .attr("dx", ".75em")-->
<!--        .style("text-anchor", "start")-->
<!--        .append("textPath")-->
<!--        .attr("startOffset", "50%")-->
<!--        .attr("class", "arc-text")-->
<!--        .attr("xlink:href", function(d, i) { return "#arc-center-" + i; });-->

<!--    tick();-->

<!--    d3.select(self.frameElement).style("height", height + "px");-->

<!--    function tick() {-->
<!--        if (!document.hidden) field-->
<!--            .each(function(d) { this._value = d.value; })-->
<!--            .data(fields)-->
<!--            .each(function(d) { d.previousValue = this._value; })-->
<!--            .transition()-->
<!--            .ease("elastic")-->
<!--            .duration(500)-->
<!--            .each(fieldTransition);-->

<!--        setTimeout(tick, 1000 - Date.now() % 1000);-->
<!--    }-->

<!--    function fieldTransition() {-->
<!--        var field = d3.select(this).transition();-->

<!--        field.select(".arc-body")-->
<!--            .attrTween("d", arcTween(arcBody))-->
<!--            .style("fill", function(d) { return color(d.value); });-->

<!--        field.select(".arc-center")-->
<!--            .attrTween("d", arcTween(arcCenter));-->

<!--        field.select(".arc-text")-->
<!--            .text(function(d) { return d.text; });-->
<!--    }-->

<!--    function arcTween(arc) {-->
<!--        return function(d) {-->
<!--            var i = d3.interpolateNumber(d.previousValue, d.value);-->
<!--            return function(t) {-->
<!--                d.value = i(t);-->
<!--                return arc(d);-->
<!--            };-->
<!--        };-->
<!--    }-->

<!--    function fields() {-->
<!--        var now = new Date;-->
<!--        return [-->
<!--            {index: .7, text: formatSecond(now), value: now.getSeconds() / 60},-->
<!--            {index: .6, text: formatMinute(now), value: now.getMinutes() / 60},-->
<!--            {index: .5, text: formatHour(now),   value: now.getHours() / 24},-->
<!--            {index: .3, text: formatDay(now),    value: now.getDay() / 7},-->
<!--            {index: .2, text: formatDate(now),   value: (now.getDate() - 1) / (32 - new Date(now.getYear(), now.getMonth(), 32).getDate())},-->
<!--            {index: .1, text: formatMonth(now),  value: now.getMonth() / 12}-->
<!--        ];-->
<!--    }-->

<!--</script>-->



<!--This example demonstrates how to use the getTotalLength and getPointAtLength methods on SVG path elements to interpolate a point along a Catmull–Rom spline.-->

<!--A related technique is stroke dash interpolation.-->

<!--<!DOCTYPE html>-->
<!--<meta charset="utf-8">-->
<!--<body>-->
<!--<style>-->

<!--    path {-->
<!--        fill: none;-->
<!--        stroke: #000;-->
<!--        stroke-width: 3px;-->
<!--    }-->

<!--    circle {-->
<!--        fill: steelblue;-->
<!--        stroke: #fff;-->
<!--        stroke-width: 3px;-->
<!--    }-->

<!--</style>-->
<!--<script src="//d3js.org/d3.v3.min.js"></script>-->
<!--<script>-->

<!--    var points = [-->
<!--        [480, 200],-->
<!--        [580, 400],-->
<!--        [680, 100],-->
<!--        [780, 300],-->
<!--        [180, 300],-->
<!--        [280, 100],-->
<!--        [380, 400]-->
<!--    ];-->

<!--    var svg = d3.select("body").append("svg")-->
<!--        .attr("width", 960)-->
<!--        .attr("height", 500);-->

<!--    var path = svg.append("path")-->
<!--        .data([points])-->
<!--        .attr("d", d3.svg.line()-->
<!--            .tension(0) // Catmull–Rom-->
<!--            .interpolate("cardinal-closed"));-->

<!--    svg.selectAll(".point")-->
<!--        .data(points)-->
<!--        .enter().append("circle")-->
<!--        .attr("r", 4)-->
<!--        .attr("transform", function(d) { return "translate(" + d + ")"; });-->

<!--    var circle = svg.append("circle")-->
<!--        .attr("r", 13)-->
<!--        .attr("transform", "translate(" + points[0] + ")");-->

<!--    transition();-->

<!--    function transition() {-->
<!--        circle.transition()-->
<!--            .duration(10000)-->
<!--            .attrTween("transform", translateAlong(path.node()))-->
<!--            .each("end", transition);-->
<!--    }-->

<!--    // Returns an attrTween for translating along the specified path element.-->
<!--    function translateAlong(path) {-->
<!--        var l = path.getTotalLength();-->
<!--        return function(d, i, a) {-->
<!--            return function(t) {-->
<!--                var p = path.getPointAtLength(t * l);-->
<!--                return "translate(" + p.x + "," + p.y + ")";-->
<!--            };-->
<!--        };-->
<!--    }-->

<!--</script>-->


<!--point along path-->
<!--Demonstrates how to use the getTotalLength and getPointAtLength methods on SVG path elements to interpolate a point along an existing path. Built with D3.-->

<!--<!DOCTYPE html>-->
<!--<meta charset="utf-8">-->
<!--<style>-->

<!--    path {-->
<!--        cursor: pointer;-->
<!--        fill: #eee;-->
<!--        stroke: #666;-->
<!--        stroke-width: 1.5px;-->
<!--    }-->

<!--    circle {-->
<!--        fill: steelblue;-->
<!--        stroke: white;-->
<!--        stroke-width: 1.5px;-->
<!--    }-->

<!--</style>-->
<!--<body>-->
<!--<script src="//d3js.org/d3.v3.min.js"></script>-->
<!--<script>-->

<!--    var width = 960,-->
<!--        height = 500;-->

<!--    var svg = d3.select("body").append("svg")-->
<!--        .attr("width", width)-->
<!--        .attr("height", height)-->
<!--        .append("g")-->
<!--        .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");-->

<!--    var path = svg.append("path")-->
<!--        .attr("d", d3.svg.arc()-->
<!--            .innerRadius(height / 4)-->
<!--            .outerRadius(height / 3)-->
<!--            .startAngle(0)-->
<!--            .endAngle(Math.PI));-->

<!--    var circle = svg.append("circle")-->
<!--        .attr("r", 6.5)-->
<!--        .attr("transform", "translate(0," + -height / 3 + ")");-->

<!--    function transition() {-->
<!--        circle.transition()-->
<!--            .duration(5000)-->
<!--            .attrTween("transform", translateAlong(path.node()))-->
<!--            .each("end", transition);-->
<!--    }-->

<!--    transition();-->

<!--    // Returns an attrTween for translating along the specified path element.-->
<!--    function translateAlong(path) {-->
<!--        var l = path.getTotalLength();-->
<!--        return function(d, i, a) {-->
<!--            return function(t) {-->
<!--                var p = path.getPointAtLength(t * l);-->
<!--                return "translate(" + p.x + "," + p.y + ")";-->
<!--            };-->
<!--        };-->
<!--    }-->

<!--</script>-->




<!--3d barchart-->
<!--<!DOCTYPE html >-->
<!--<html >-->
<!--<head>-->
<!--  <meta http-equiv="X-UA-Compatible" content="chrome=1" />-->
<!--  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />-->
<!--  <title>d3 x3dom demo</title>-->
<!--  <script src="//d3js.org/d3.v3.min.js"></script>-->
<!--  <script type="text/javascript" src="http://x3dom.org/x3dom/example/x3dom.js"></script>-->
<!--</head>-->
<!--<body>-->
<!--<script>-->
<!--  function randomData() {-->
<!--    return d3.range(6).map( function() { return Math.random()*20; } )-->
<!--  };-->

<!--  x3d = d3.select("body")-->
<!--          .append("x3d")-->
<!--          .attr( "height", "400px" )-->
<!--          .attr( "width", "400px" )-->
<!--  ;-->
<!--  var scene = x3d.append("scene");-->
<!--  scene.append("viewpoint")-->
<!--          .attr( "centerOfRotation", "3.75 0 10")-->
<!--          .attr( "position", "13.742265188709691 -27.453522975182366 16.816062840792625" )-->
<!--          .attr( "orientation", "0.962043810961999 0.1696342804961945 0.21376603254551874 1.379433089729343" )-->
<!--  ;-->

<!--  function refresh( data ) {-->
<!--    shapes = scene.selectAll("transform").data( data );-->
<!--    shapesEnter = shapes-->
<!--            .enter()-->
<!--            .append( "transform" )-->
<!--            .append( "shape" )-->
<!--    ;-->
<!--    // Enter and update-->
<!--    shapes.transition()-->
<!--            .attr("translation", function(d,i) { return i*1.5 + " 0.0 " + d/2.0; } )-->
<!--            .attr("scale", function(d) { return "1.0 1.0 " + d; } )-->
<!--    ;-->

<!--    shapesEnter-->
<!--            .append("appearance")-->
<!--            .append("material")-->
<!--            .attr("diffuseColor", "steelblue" );-->

<!--    shapesEnter.append( "box" )-->
<!--            .attr( "size", "1.0 1.0 1.0" );-->
<!--  }-->

<!--  refresh( randomData() )-->
<!--  setInterval(-->
<!--          function(){-->
<!--            refresh( randomData() );-->
<!--          },-->
<!--          2500);-->

<!--</script>-->
<!--</body>-->
<!--</html>-->



<!--<!DOCTYPE html>-->
<!--<meta charset="utf-8">-->
<!--<style>-->

<!--  .axis text {-->
<!--    font: 10px sans-serif;-->
<!--  }-->

<!--  .axis line,-->
<!--  .axis path {-->
<!--    fill: none;-->
<!--    stroke: #000;-->
<!--    shape-rendering: crispEdges;-->
<!--  }-->

<!--</style>-->
<!--<body>-->
<!--<script src="//d3js.org/d3.v3.min.js"></script>-->
<!--<script>-->

<!--  var duration = 2500,-->
<!--          delay = 500;-->

<!--  var width = 960,-->
<!--          height = 500;-->

<!--  var x = d3.time.scale()-->
<!--          .domain([new Date(2010, 0, 2), new Date(2010, 1, 1)])-->
<!--          .range([0, width]);-->

<!--  var xAxis = d3.svg.axis()-->
<!--          .scale(x)-->
<!--          .orient("bottom")-->
<!--          .tickSize(6, 0)-->
<!--          .tickFormat(d3.time.format("%m/%d"));-->

<!--  var svg = d3.select("body").append("svg")-->
<!--          .attr("width", width)-->
<!--          .attr("height", height);-->

<!--  var g = svg.append("g")-->
<!--          .attr("class", "axis")-->
<!--          .attr("transform", "translate(0," + height / 2 + ")")-->
<!--          .call(xAxis);-->

<!--  setInterval(update, duration + delay);-->

<!--  function update() {-->
<!--    x.domain([new Date(2010, 0, 2), new Date(2010, 0, Math.floor(Math.random() * 21) + 10)]);-->

<!--    g.transition()-->
<!--            .duration(duration)-->
<!--            .call(xAxis);-->
<!--  }-->

<!--</script>-->



<!--水波纹-->
<!--<!DOCTYPE html>-->
<!--<meta charset="utf-8">-->
<!--<body>-->
<!--<script src="https://d3js.org/d3.v3.min.js"></script>-->
<!--<script>-->

<!--  // Register the "custom" namespace prefix for our custom elements.-->
<!--  d3.ns.prefix.custom = "https://d3js.org/namespace/custom";-->

<!--  var width = 960,-->
<!--          height = 500;-->

<!--  // Add our "custom" sketch element to the body.-->
<!--  var sketch = d3.select("body").append("custom:sketch")-->
<!--          .attr("width", width)-->
<!--          .attr("height", height)-->
<!--          .call(custom);-->

<!--  // On each mouse move, create a circle that increases in size and fades away.-->
<!--  d3.select(window).on("mousemove", function() {-->
<!--    sketch.append("custom:circle")-->
<!--            .attr("x", d3.event.clientX)-->
<!--            .attr("y", d3.event.clientY)-->
<!--            .attr("radius", 0)-->
<!--            .attr("strokeStyle", "red")-->
<!--            .transition()-->
<!--            .duration(2000)-->
<!--            .ease(Math.sqrt)-->
<!--            .attr("radius", 200)-->
<!--            .attr("strokeStyle", "white")-->
<!--            .remove();-->
<!--  });-->

<!--  function custom(selection) {-->
<!--    selection.each(function() {-->
<!--      var root = this,-->
<!--              canvas = root.parentNode.appendChild(document.createElement("canvas")),-->
<!--              context = canvas.getContext("2d");-->

<!--      canvas.style.position = "absolute";-->
<!--      canvas.style.top = root.offsetTop + "px";-->
<!--      canvas.style.left = root.offsetLeft + "px";-->

<!--      // It'd be nice to use DOM Mutation Events here instead.-->
<!--      // However, they appear to arrive irregularly, causing choppy animation.-->
<!--      d3.timer(redraw);-->

<!--      // Clear the canvas and then iterate over child elements.-->
<!--      function redraw() {-->
<!--        canvas.width = root.getAttribute("width");-->
<!--        canvas.height = root.getAttribute("height");-->
<!--        for (var child = root.firstChild; child; child = child.nextSibling) draw(child);-->
<!--      }-->

<!--      // For now we only support circles with strokeStyle.-->
<!--      // But you should imagine extending this to arbitrary shapes and groups!-->
<!--      function draw(element) {-->
<!--        switch (element.tagName) {-->
<!--          case "circle": {-->
<!--            context.strokeStyle = element.getAttribute("strokeStyle");-->
<!--            context.beginPath();-->
<!--            context.arc(element.getAttribute("x"), element.getAttribute("y"), element.getAttribute("radius"), 0, 2 * Math.PI);-->
<!--            context.stroke();-->
<!--            break;-->
<!--          }-->
<!--        }-->
<!--      }-->
<!--    });-->
<!--  };-->

<!--</script>-->





<!--barchart growing one by one-->

<!--<!DOCTYPE html>-->
<!--<html lang="en">-->
<!--<head>-->
<!--    <meta charset="UTF-8">-->
<!--    <meta name="viewport" content="width=device-width, initial-scale=1.0">-->
<!--    <title>Animated Bar Chart</title>-->
<!--    <script src="https://d3js.org/d3.v6.min.js"></script>-->
<!--    <style>-->
<!--        /* Add your custom styles here */-->
<!--    </style>-->
<!--</head>-->
<!--<body>-->
<!--<svg id="bar-chart"></svg>-->

<!--<script>-->
<!--    const data = [-->
<!--        { label: "A", value: 10 },-->
<!--        { label: "B", value: 15 },-->
<!--        { label: "C", value: 30 },-->
<!--        { label: "D", value: 20 },-->
<!--    ];-->

<!--    const width = 800;-->
<!--    const height = 400;-->
<!--    const margin = { top: 20, right: 20, bottom: 30, left: 40 };-->

<!--    const svg = d3.select("#bar-chart")-->
<!--        .attr("width", width)-->
<!--        .attr("height", height);-->

<!--    const x = d3.scaleBand()-->
<!--        .domain(data.map(d => d.label))-->
<!--        .range([margin.left, width - margin.right])-->
<!--        .padding(0.1);-->

<!--    const y = d3.scaleLinear()-->
<!--        .domain([0, d3.max(data, d => d.value)])-->
<!--        .nice()-->
<!--        .range([height - margin.bottom, margin.top]);-->

<!--    const xAxis = svg.append("g")-->
<!--        .attr("transform", `translate(0,${height - margin.bottom})`)-->
<!--        .call(d3.axisBottom(x));-->

<!--    const yAxis = svg.append("g")-->
<!--        .attr("transform", `translate(${margin.left},0)`)-->
<!--        .call(d3.axisLeft(y));-->

<!--    const bar = svg.selectAll(".bar")-->
<!--        .data(data)-->
<!--        .join("rect")-->
<!--        .attr("class", "bar")-->
<!--        .attr("x", d => x(d.label))-->
<!--        .attr("width", x.bandwidth())-->
<!--        .attr("y", height - margin.bottom)-->
<!--        .attr("height", 0)-->
<!--        .style("fill", "#69b3a2"); // Or any other color you'd like-->

<!--    bar.transition()-->
<!--        .duration(1000)-->
<!--        .ease(d3.easeCubicInOut)-->
<!--        .delay((d, i) => i * 200)-->
<!--        .attr("y", d => y(d.value))-->
<!--        .attr("height", d => y(0) - y(d.value));-->

<!--</script>-->
<!--</body>-->
<!--</html>-->



<!--<!DOCTYPE html>-->
<!--<html>-->
<!--<head>-->
<!--    <meta charset="utf-8">-->
<!--    <style>-->
<!--        .bar {-->
<!--            fill: steelblue;-->
<!--        }-->

<!--        .token {-->
<!--            fill: #ff7f0e;-->
<!--            opacity: 0.8;-->
<!--        }-->
<!--    </style>-->
<!--</head>-->
<!--<body>-->
<!--<script src="https://d3js.org/d3.v6.min.js"></script>-->
<!--<script>-->
<!--    const data = [-->
<!--        { category: 'AI for retail', value: 0, maxValue: 57.8 },-->
<!--        { category: 'AI for education', value: 0, maxValue: 23.92 },-->
<!--        { category: 'AI for transportation', value: 0, maxValue: 14.79 },-->
<!--        { category: 'AI in healthcare', value: 0, maxValue: 188 }-->
<!--    ];-->

<!--    const margin = { top: 20, right: 20, bottom: 40, left: 40 };-->
<!--    const width = 600 - margin.left - margin.right;-->
<!--    const height = 400 - margin.top - margin.bottom;-->
<!--    const tokenSize = 6;-->

<!--    const x = d3.scaleBand()-->
<!--        .domain(data.map(d => d.category))-->
<!--        .rangeRound([0, width])-->
<!--        .padding(0.1);-->

<!--    // const y = d3.scaleLinear()-->
<!--    //     .domain([0, d3.max(data, d => d.maxValue) * (tokenSize * 2)])-->
<!--    //     .range([height, 0]);-->

<!--    const y = d3.scaleLinear()-->
<!--        .domain([0, d3.max(data, d => d.maxValue) * (tokenSize * 2)])-->
<!--        .range([height, 0]);-->

<!--    // const y = d3.scaleLinear()-->
<!--    //     .domain([0, Math.max(...data.map(d => d.maxValue))])-->
<!--    //     .range([height, 0]);-->

<!--    const svg = d3.select("body")-->
<!--        .append("svg")-->
<!--        .attr("width", width + margin.left + margin.right)-->
<!--        .attr("height", height + margin.top + margin.bottom)-->
<!--        .append("g")-->
<!--        .attr("transform", `translate(${margin.left}, ${margin.top})`);-->

<!--    const bars = svg.selectAll(".bar")-->
<!--        .data(data)-->
<!--        .enter().append("rect")-->
<!--        .attr("class", "bar")-->
<!--        .attr("x", d => x(d.category))-->
<!--        .attr("y", height)-->
<!--        .attr("width", x.bandwidth())-->
<!--        .attr("height", 0);-->

<!--    const tokens = [];-->

<!--    function ticked() {-->
<!--        svg.selectAll(".token")-->
<!--            .attr("cx", d => d.x)-->
<!--            .attr("cy", d => d.y);-->
<!--    }-->

<!--    const tokenMap = new Map();-->
<!--    const simulationMap = new Map();-->

<!--    data.forEach((d) => {-->
<!--        tokenMap.set(d.category, []);-->

<!--        const simulation = d3.forceSimulation()-->
<!--            .force("x", d3.forceX().strength(0.07).x((token) => token.targetX))-->
<!--            .force("y", d3.forceY().strength(0.28).y((token) => token.targetY))-->
<!--            .force("collide", d3.forceCollide(tokenSize))-->
<!--            .on("tick", () => {-->
<!--                limitBarWidth(d.category);-->
<!--                ticked();-->
<!--            });-->


<!--        simulationMap.set(d.category, simulation);-->
<!--    });-->

<!--    function limitBarWidth(category) {-->
<!--        const tokens = tokenMap.get(category);-->

<!--        for (const token of tokens) {-->
<!--            const barX = x(token.category);-->
<!--            const barWidth = x.bandwidth();-->
<!--            const xMin = barX + token.radius;-->
<!--            const xMax = barX + barWidth - token.radius;-->

<!--            if (token.x < xMin) {-->
<!--                token.x = xMin;-->
<!--            }-->
<!--            if (token.x > xMax) {-->
<!--                token.x = xMax;-->
<!--            }-->

<!--            // Update token.targetY to keep it above the bar-->
<!--            // const barHeight = data.find(d => d.category === token.category).value * (tokenSize * 2);-->
<!--            // const barY = height - barHeight;-->
<!--            // const yMax = barY - token.radius*3;-->
<!--            const barHeight = height - y(data.find(d => d.category === token.category).value * scaleFactor);-->
<!--            const barY = y(data.find(d => d.category === token.category).value * scaleFactor);-->
<!--            const yMax = barY - token.radius * scaleFactor;-->
<!--            // const barHeight = height - y(data.find(d => d.category === token.category).value);-->
<!--            // const barY = y(data.find(d => d.category === token.category).value);-->
<!--            // const yMax = barY - token.radius * 3;-->

<!--            if (token.y > yMax) {-->
<!--                token.targetY = yMax;-->
<!--            }-->
<!--            // Prevent token from going below the bar top-->
<!--            if (token.y + token.radius >= barY) {-->
<!--                token.y = barY - token.radius * scaleFactor;-->
<!--            }-->

<!--        }-->
<!--    }-->
<!--    const scaleFactor = 2;-->

<!--    function addToken(categoryIndex) {-->
<!--        const category = data[categoryIndex].category;-->
<!--        const tokens = tokenMap.get(category);-->
<!--        const simulation = simulationMap.get(category);-->

<!--        const barHeight = height - y(data[categoryIndex].value * scaleFactor);-->
<!--        const barY = y(data[categoryIndex].value * scaleFactor);-->
<!--        // const category = data[categoryIndex].category;-->
<!--        // const tokens = tokenMap.get(category);-->
<!--        // const simulation = simulationMap.get(category);-->
<!--        //-->
<!--        // const barHeight = data[categoryIndex].value * tokenSize * 2;-->
<!--        // const barY = height - barHeight;-->

<!--        // Check if the bar has reached its maximum value, and if so, do not add a new token-->
<!--        if (data[categoryIndex].value >= data[categoryIndex].maxValue) {-->
<!--            return;-->
<!--        }-->

<!--        const token = {-->
<!--            category: category,-->
<!--            value: data[categoryIndex].value,-->
<!--            x: x(category) + x.bandwidth() / 2,-->
<!--            y: -tokenSize,-->
<!--            targetX: x(category) + Math.random() * x.bandwidth(),-->
<!--            targetY: barY - tokenSize * 3,-->
<!--            radius: tokenSize-->
<!--        };-->

<!--        tokens.push(token);-->


<!--        // Check if the bar has more than 10 tokens, and if so, remove the oldest one-->
<!--        // if (tokens.length > 5) {-->
<!--        //     tokens[0].disappearing = true;-->
<!--        //     disappearToken(tokens[0]);-->
<!--        //     tokens.shift(); // Remove the first token from the array-->
<!--        // }-->
<!--        data[categoryIndex].value += 1;-->
<!--        updateBars();-->

<!--        const circles = svg.selectAll(`.token-${category}`)-->
<!--            .data(tokens)-->
<!--            .join("circle")-->
<!--            .attr("class", `token token-${category}`)-->
<!--            .attr("r", (d) => d.radius);-->

<!--        simulation.nodes(tokens);-->
<!--        simulation.alpha(1).restart();-->
<!--    }-->

<!--    function updateBars() {-->
<!--        bars.data(data)-->
<!--            .transition()-->
<!--            .duration(500)-->
<!--            .attr("y", d => y(d.value))-->
<!--            .attr("height", d => height - y(d.value));-->
<!--    }-->

<!--    // function updateBars() {-->
<!--    //     bars.data(data)-->
<!--    //         .transition()-->
<!--    //         .duration(200)-->
<!--    //         .attr("y", d => height - d.value * tokenSize * 2)-->
<!--    //         .attr("height", d => d.value * tokenSize * 2);-->
<!--    // }-->
<!--    function disappearToken(token) {-->
<!--        if (!token.disappearing) return;-->

<!--        token.radius = Math.max(0, token.radius - 0.1);-->
<!--        svg.selectAll(".token")-->
<!--            .data(tokens)-->
<!--            .attr("r", d => d.radius);-->

<!--        if (token.radius <= 0) {-->
<!--            tokens.splice(tokens.indexOf(token), 1);-->
<!--        } else {-->
<!--            requestAnimationFrame(() => {-->
<!--                disappearToken(token);-->
<!--            });-->
<!--        }-->
<!--    }-->

<!--    setInterval(() => {-->
<!--        const categoryIndex = Math.floor(Math.random() * data.length);-->
<!--        addToken(categoryIndex);-->
<!--    }, 500);-->
<!--</script>-->
<!--</body>-->
<!--</html>-->












<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <style>
        .bar {
            fill: rgba(231, 212, 202, 0.56);
        }

        .token {
            fill: rgba(248, 184, 184, 0.86);
            opacity: 0.8;
        }

        .category-label {
            font-family: 'Arial', sans-serif;
            font-size: 12px;
            fill: rgb(61, 140, 168);
        }

    </style>
</head>
<body>
<svg>

</svg>
<button id="startButton">Start</button>
<button id="resetButton">Reset</button>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script>


    const dataAIMarket = [
        { category: "Healthcare", value: 0, maxValue: 188 },
        { category: "Agriculture", value: 0, maxValue: 7.3 },
        { category: "Finance", value: 0, maxValue: 41.6 },
        { category: "Marketing", value: 0, maxValue: 1591 },
        { category: "Automotive", value: 0, maxValue: 20 },
        { category: "Food", value: 0, maxValue: 15 },
        { category: "Manufacturing", value: 0, maxValue: 52.4 },
        { category: "Construction", value: 0, maxValue: 5 },
        { category: "HR", value: 0, maxValue: 56.2 },
        { category: "Retail", value: 0, maxValue: 57.8 },
        { category: "Education", value: 0, maxValue: 23.92 },
        { category: "Transportation", value: 0, maxValue: 14.79 }
    ];

    const screenWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
    const margin = { top: 20, right: 20, bottom: 40, left: 40 };
    const width = screenWidth - margin.left - margin.right;
    const height = 400 - margin.top - margin.bottom;

    const x = d3.scaleBand()
        .domain(dataAIMarket.map(d => d.category))
        .rangeRound([0, width])
        .padding(0.1);

    const maxValueExtent = d3.extent(dataAIMarket, d => d.maxValue);

    const logScale = d3.scaleLog()
        .domain(maxValueExtent)
        .range([0, height]);

    dataAIMarket.forEach(d => {
        d.scaledMaxValue = logScale(d.maxValue);
    });

    const y = d3.scaleLinear()
        .domain(d3.extent(dataAIMarket, d => d.scaledMaxValue))
        .range([0, height]);

    const numSegments = 50;
    const tokenSize = height / numSegments;

    dataAIMarket.forEach(d => {
        d.maxTokenNumValue = Math.floor(y(d.scaledMaxValue) / tokenSize);
        console.log(d.category, y(d.scaledMaxValue), d.maxTokenNumValue);
    });

    const svg = d3.select("svg")
        .attr("width", screenWidth)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", `translate(${margin.left}, ${margin.top})`);

    // Gooey effect filter
    const defs = svg.append("defs");
    const filter = defs.append("filter")
        .attr("id", "gooey");

    filter.append("feGaussianBlur")
        .attr("in", "SourceGraphic")
        .attr("stdDeviation", "10")
        .attr("result", "blur");

    filter.append("feColorMatrix")
        .attr("in", "blur")
        .attr("mode", "matrix")
        .attr("values", "1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 18 -7")
        .attr("result", "gooey");

    filter.append("feComposite")
        .attr("in", "SourceGraphic")
        .attr("in2", "gooey")
        .attr("operator", "atop");

    const circleGroup = svg.append("g")
        .style("filter", "url(#gooey)");

    const bars = svg.selectAll(".bar")
        .data(dataAIMarket)
        .enter().append("rect")
        .attr("class", "bar")
        .attr("x", d => x(d.category))
        .attr("y", height)
        .attr("width", x.bandwidth())
        .attr("height", 0);

    const categoryLabels = svg.selectAll(".category-label")
        .data(dataAIMarket)
        .enter().append("text")
        .attr("class", "category-label")
        .attr("x", d => x(d.category) + x.bandwidth() / 2)
        .attr("y", d => margin.top/2)
        .attr("text-anchor", "middle")
        .text(d => d.category)
        .attr("opacity", 0)
        .transition()
        .duration(2500)
        // .delay((d, i) => i * 200)
        .attr("opacity", 1);

    const tokens = [];

    function ticked() {
        svg.selectAll(".token")
            .attr("cx", d => d.x)
            .attr("cy", d => d.y)
            //.style("filter", "url(#gooeyCodeFilter)"); // Apply filter to circles
    }
    const tokenMap = new Map();
    const simulationMap = new Map();

    dataAIMarket.forEach((d) => {
        tokenMap.set(d.category, []);

        const simulation = d3.forceSimulation(tokens)
            .force("x", d3.forceX((token) => token.targetX).strength(0.07))
            .force("y", d3.forceY((token) => token.targetY).strength(0.28))
            .force("collide", d3.forceCollide(tokenSize))
            .on("tick", () => {
                limitBarWidth(d.category);
                ticked();
            });



        simulationMap.set(d.category, simulation);
    });

    function limitBarWidth(category) {
        const tokens = tokenMap.get(category);

        for (const token of tokens) {
            const barX = x(token.category);
            const barWidth = x.bandwidth();
            const xMin = barX + token.radius;
            const xMax = barX + barWidth - token.radius;

            if (token.x < xMin) {
                token.x = xMin;
            }
            if (token.x > xMax) {
                token.x = xMax;
            }

            // Update token.targetY to keep it above the bar
            const barHeight = dataAIMarket.find(d => d.category === token.category).value * (tokenSize * 2);
            const barY = height - barHeight;
            const yMax = barY - token.radius*3;

            if (token.y > yMax) {
                token.targetY = yMax;
            }
            // Prevent token from going below the bar top
            if (token.y >= barY) {
                token.y = barY - token.radius*3;
            }

        }
    }

    function addToken(categoryIndex) {
        const category = dataAIMarket[categoryIndex].category;
        const tokens = tokenMap.get(category);
        const simulation = simulationMap.get(category);

        const barHeight = dataAIMarket[categoryIndex].value * tokenSize * 2;
        const barY = height - barHeight;

        const token = {
            category: category,
            value: dataAIMarket[categoryIndex].value,
            x: x(category) + x.bandwidth() / 2,
            y: -tokenSize,
            targetX: x(category) + Math.random() * x.bandwidth(),
            targetY: barY - tokenSize * 3,
            radius: tokenSize
        };

        tokens.push(token);

        // Check if the bar has more than 10 tokens, and if so, remove the oldest one
        if (tokens.length > 5) {
            tokens[0].disappearing = true;
            disappearToken(tokens[0]);
            tokens.shift(); // Remove the first token from the array
        }

        dataAIMarket[categoryIndex].value += 1;
        updateBars();

        const circles = svg.selectAll(`.token-${category}`)
            .data(tokens)
            .join("circle")
            .attr("class", `token token-${category}`)
            .attr("r", (d) => d.radius);


        simulation.nodes(tokens);
        simulation.alpha(1).restart();
    }


    function updateBars() {
        bars.data(dataAIMarket)
            .transition()
            .duration(500)
            .attr("y", d => height - d.value * tokenSize * 2)
            .attr("height", d => d.value * tokenSize * 2)
    }

    function disappearToken(token) {
        if (!token.disappearing) return;

        token.radius = Math.max(0, token.radius - 0.1);
        svg.selectAll(".token")
            .data(tokens)
            .attr("r", d => d.radius);

        if (token.radius <= 0) {
            tokens.splice(tokens.indexOf(token), 1);
        } else {
            requestAnimationFrame(() => {
                disappearToken(token);
            });
        }
    }

    function barReachedTop(index) {
        return dataAIMarket[index].value >= dataAIMarket[index].maxTokenNumValue/2;
    }

    // Initialize the availableCategories array with all indices
    const availableCategories = dataAIMarket.map((_, index) => index);

    let intervalId;

    function startAnimation() {
        intervalId = setInterval(() => {
            if (availableCategories.length === 0) {
                clearInterval(intervalId); // Stop the interval when all bars reached the top
            } else {
                const randomIndex = Math.floor(Math.random() * availableCategories.length);
                const categoryIndex = availableCategories[randomIndex];

                addToken(categoryIndex);

                if (barReachedTop(categoryIndex)) {
                    availableCategories.splice(randomIndex, 1);
                }
            }
        }, 500);
    }

    function resetAnimation() {
        clearInterval(intervalId);
        availableCategories.length = 0;
        dataAIMarket.forEach((d, index) => {
            d.value = 0;
            availableCategories.push(index);
            const tokens = tokenMap.get(d.category);
            tokens.length = 0;
            tokenMap.set(d.category, tokens);
        });
        updateBars();
        svg.selectAll(".token").remove();
    }

    document.getElementById("startButton").addEventListener("click", startAnimation);
    document.getElementById("resetButton").addEventListener("click", resetAnimation);

</script>
</body>
</html>





